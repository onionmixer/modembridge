==level3 작업내역==

작업 대상을 level3 로 제한합니다. level3 작업시에는 level1 과 level2 의 thread 를 enable 합니다.

level3 의 코드는 현재 프로젝트가 안정화가 될 때까지 다른 level 과 공유를 최소화 하는 방향으로 진행합니다.

level3 는 level1 과 level 2 의 data 입출력을 연결해서 관리하는 역할입니다. 2개의 data pipeline 을 유지해야 합니다.


1. level1 의 client -> modem 접속 완료
2. level2 의 telnet server 접속 완료
3. level1 및 level2 의 연결이 완료 되었을때 level3 의 data pipeline 작업 시작


이상이 level3 구동의 기본 개념입니다.

* level3 pipeline 1 : level1 의 serial receive to level 2 telnet server send
** pipeline1 main buffer, pipeline1 sub buffer
* level3 pipeline 2 : level2 의 telnet server receive to level 1 serial send
** pipeline2 main buffer, pipeline2 sub buffer

1. level3 의 pipeline 은 level1 에서 modem 접속시 client 와의 연결 이후 최종적으로 negotiaion 된 serial port speed 를 참고해서 동작할 수 있어야 합니다.

2. pipeline 1 에서 모뎀제어용 헤이즈 코드는 level2 의 telnet server 로 넘어가기 전에 필터링 되어야 합니다.

3. pipeline 2 에서 telnet server 에서 받은 TELNET 제어코드는 serial port 로 넘어가기 전에 필터링 되어야 합니다. 단 ANSI 코드는 전달되어도 좋습니다.

4. pipeline1 과 2는 각가가의 buffer 를 가지고 있으며, 서로 직렬관계에서 FLAG 형태로 관리 되어야 한다.

5. level1 의 serial port 는 송신과 수신을 동시게 하기 힘든 구조를 가지고 있고, 특히 modem 의 연결이 1200 bps 로 되는 최악의 상황을 가정해야 한다.

6. level2 는 능동적으로 데이터를 주고받을 수 있다고 해도,  level3 는 pipeline1 의 data flow 가 시작되었을때, 그 데이터는 serial 에서 필요한 만큼 받은다음 buffer 처리해서 모뎀 제어코드 필터를 거쳐서 telnet server 로 보내고 pipeline 1 의 buffer 를 비우는 작업이 진행될때, pipeline2 는 level2 에서 수신된 데이터를 별도의 buffer 로 가지고 있다가 pipeline 1 의 buffer 처리가 끝나면, 그때 pipepile2 의 buffer 를 TELNET 제어코드 필터링을 해서 level1 으로 보내고 pipeline2 의 buffer 를 비워야 한다.

7. level3 의 2개 pipeline 은 level1 의 serial port 를 기준으로 half duplex 로 동작할 수 있어야 한다.

8. 각 pipeline 은 main buffer 와 sub buffer 를 각각 가지고 있어야 한다. 그래야 각 pipeline 의 데이터가 half duplex 로 동작하며 main buffer 를 비워낼때, 각각 level 에서 수신되는 데이터를 sub buffer 에 저장할 수 있기 때문이다.

9. 이렇게 복잡하게 로직을 구성하는 이유는 level 2 에서 접속하게되는 telnet server 중에 realtime chat server 가 있기 때문이다.


10. "시나리오에 필요한 DCD 기반 상태 전이" 는 level1 의 코드를 검토하고 필요하다면 level1 내에서 코드를 보강합니다.

11. "텔넷 협상·이스케이프" 처리는 level2 의 코드를 검토하고 필요하다면 level2 내에서 처리합니다.

12. 공정 스케줄링, 백프레셔·수위선



==검토 후 주의사항==

제시한 시나리오는 큰 틀에서 가능하지만 모뎀/텔넷의 물리·프로토콜 특성을 반영한 상태 전이와 흐름제어, 공정한 스케줄링을 보강하지 않으면 지연 증가, 버퍼 오버런, 기아 상태가 발생할 수 있습니다. 특히 pipeline 간 "순차 배출"만으로 half duplex를 흉내 내면 실시간 채팅에서 상호작용성이 크게 저하될 수 있어, 시간 또는 바이트 단위의 공정 분할과 백프레셔 설계가 필요합니다.

===상태 전이와 데이터 구분===

* CONNECTING 같은 임의 문자열이 아니라 DCD(캐리어 감지)와 표준 결과 코드(RING/CONNECT/NO CARRIER)를 기반으로 명령 모드와 데이터 모드를 구분하세요.

* 모뎀 에코와 결과 코드 표시를 제어해 서버가 판별하기 쉽게 하되(예: ATE0, Q0, V1, X4), 데이터 모드 전환의 최종 근거는 DCD 상승/하강으로 삼는 것이 안정적입니다.

===직렬 속도와 흐름 제어===

* "최종 협상된 직렬 속도"를 동적으로 따르기보다는 DTE(호스트↔모뎀) 속도를 고정(예: 57600/115200)하고 하드웨어(RTS/CTS) 또는 소프트웨어(XON/XOFF) 흐름제어로 조절하는 구성이 버퍼 관리에 유리합니다.

* 최악의 1200 bps를 가정한다면 텔넷 측 송신을 직렬 속도에 맞춰 트래픽 셰이핑하고, 고수위/저수위 수위선 기반의 백프레셔로 오버런을 방지하세요.

===스케줄링과 공정성===

* "pipeline1 처리 완료 후 pipeline2 처리" 같은 완전 순차 정책은 긴 상향(혹은 하향) 버스트에서 반대 방향을 장시간 지연시켜 대화형 UX를 해칩니다.

* 바이트 N개 단위 혹은 기간 T ms 단위 라운드로빈, 필요 시 가중치가 있는 공정 대기열(예: 1200 bps쪽에 가중치)을 적용해 상호 지연을 제한하세요.

===텔넷 특이사항===

* 텔넷 제어 IAC(0xFF) 시퀀스는 완전 필터링이 아니라 협상·이스케이프 처리가 필요합니다. 이진 전송(파일 전송 등)을 지원하려면 BINARY 옵션 협상과 0xFF 이스케이프를 구현하세요.

* CR/LF 규칙(NVT)과 ANSI 시퀀스 전달 정책을 분리하세요. ANSI는 전달하되 줄바꿈 변환과 탭 처리 등은 텔넷 규범을 따르도록 하세요.

===모뎀 특이사항===

* Hayes 명령 필터링은 "명령 모드"에서만 적용되어야 하며, 데이터 모드 중에는 사용자가 보낸 "+++"가 우발적으로 명령 모드로 탈출하지 않도록 S-레지스터(예: S2, S12)나 에스케이프 무효화를 검토하세요.

* DTR/DCD 연동(&D2, &C1)을 일관되게 쓰고, NO CARRIER 수신 또는 DCD 하강 시 즉시 데이터 모드 종료·정리로 전이하세요.

===버퍼링 설계===

* main/sub 이중 버퍼만으로는 장시간 역방향 폭주 시 메모리 증식이나 기아 상태가 생길 수 있습니다. 수위선(고수위 시 송신 차단/감속)과 최대 축적량을 둬서 방어하세요.

* 각 버퍼 작업은 잠금 경쟁과 인버전이 없도록 단일 스레드 이벤트 루프(비동기 I/O)나 lock-free 원형 버퍼로 단순화하는 편이 안전합니다.

===half duplex 가정의 위험===

* RS-232 기반 모뎀 연결은 물리적으로 전이중이 가능하며, 소프트웨어적 half duplex 게이트는 불필요한 지연을 유발할 수 있습니다.

* 정말로 직렬 장치가 동시 송수신이 어려운 구조라면, 매우 짧은 타임슬라이스로 상·하향을 교대로 처리하고, 인터럽트/드라이버 버퍼 특성에 맞춘 최소 단위(예: 32–128바이트)를 사용하세요.

===파이프라인 시작·종료 조건===

* level1과 level2가 모두 준비되고 DCD가 상승된 뒤에만 pipeline을 활성화하고, 어느 한쪽이 닫히거나 DCD 하강 시 즉시 양방향을 정리·종료하세요.

* 종료 시 미전송 데이터 플러시와 타임아웃을 분리해, 끊김 상황에서 무한 대기하지 않도록 하세요.

===필터링 범위 명확화===

* pipeline1에서는 명령 모드 결과 코드(OK, RING, CONNECT, NO CARRIER 등)와 에코만 제거하고, 데이터 모드 전환 후에는 무해한 제어코드만 최소한으로 개입하세요.

* pipeline2에서는 텔넷 제어(IAC)만 처리하고, ANSI/일반 텍스트는 그대로 전달하되, 직렬 장치가 이해하지 못할 특수 제어는 안전하게 드롭 또는 변환하세요.

===권장 보완안===

* 상태 머신: 초기화→대기(명령 모드)→응답/협상→데이터 모드→종료의 명확한 전이와 타임아웃을 정의하세요.

* 속도·흐름: DTE 속도 고정+흐름제어, 텔넷 측 트래픽 셰이핑, 수위선 기반 백프레셔를 기본으로 하세요.

* 스케줄링: 공정 분할(시간/바이트 단위)로 양방향 지연 상한을 보장하고, 장시간 버스트에도 기아가 없도록 하세요.

===결론===

* 설계의 핵심 아이디어(양방향 파이프라인, 명령/데이터 필터링, 버퍼 분리)는 타당하지만, half duplex 강제와 순차 배출만으로는 실시간성·안정성이 부족합니다. 해당 부분을 보강하는게 좋습니다.

