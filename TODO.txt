ModemBridge - TODO & Development Progress
==========================================

프로젝트 개요:
-------------
ModemBridge: USB 시리얼 모뎀을 Telnet 서버에 연결하는 C 기반 브리지 서버
- Hayes AT 명령어 에뮬레이션
- 시리얼/Telnet 프로토콜 변환
- BBS 호스트/클라이언트 모드 지원


완료된 Phase 목록:
==================

✅ Phase 1-10: 기본 구현 (완료)
   - 시리얼 통신, Telnet 프로토콜, AT 명령어, 브리지 로직
   - 설정 파일, 로깅, 데몬 모드
   - 통합 테스트 및 디버깅

✅ Phase 11: 문서화 개선 (완료)
   - 사용자 가이드 (USER_GUIDE.md)
   - AT 명령어 레퍼런스 (AT_COMMANDS.md)
   - 설정 가이드 (CONFIGURATION.md)
   - 문제 해결 (TROUBLESHOOTING.md)
   - 사용 예제 (EXAMPLES.md)
   - API 레퍼런스 (API_REFERENCE.md)

✅ Phase 12: Resilient Architecture 및 Health Check (완료)
   - 자동 복구 메커니즘
   - Health check 시스템
   - 연결 모니터링

✅ Phase 13: MODEM_COMMAND 기능 추가 (완료)
   - 설정 파일에서 모뎀 초기화 명령어 지정
   - 하드웨어 모뎀 직접 초기화 지원

✅ Phase 14: Serial Port 명시적 초기화 단계 추가 (완료)
   - 시리얼 포트 lock/unlock
   - Blocking mode 설정
   - 초기화 응답 draining

✅ Phase 15: BBS 호스트 모드 지원 (완료)
   - DTR/DCD 관리
   - 자동응답 (ATA) 구현
   - RING 감지 및 처리
   - Carrier detect 모니터링

✅ Phase 16: 추가 AT 명령어 구현 (완료)
   - AT&C (DCD 제어)
   - AT&D (DTR 동작)
   - ATB (Bell/CCITT 모드)
   - ATX (Extended result codes)
   - ATL/ATM (스피커 제어)
   - AT\N (Error correction)
   - AT&S (DSR override)
   - AT&V (설정 보기)
   - AT&W (설정 저장)

✅ Phase 17: 프로덕션 배포 (선택사항, 미실행)
   - systemd service
   - 패키징 (deb/rpm)


================================================================================
Phase 18: Level 1 개발 (Timestamp 전송 및 기본 동작) - ✅ 완료
================================================================================

목표:
-----
Level 1 구현: 연결 후 주기적으로 timestamp를 전송하는 기본 기능
- CONNECT 후 즉시 첫 번째 timestamp 전송
- 이후 10초마다 timestamp 전송
- 형식: "\r\n[YYYY-MM-DD HH:MM:SS] Level 1 Active\r\n"
- 상태: ✅ 완료 및 테스트 성공 (2025-10-17)

작업 내역:
---------

[18-1] ✅ Baudrate 조정 로직 확인 및 개선 (완료)
문제: CONNECT 메시지 수신 시 baudrate 조정 과정이 stdout에 표시 안 됨
위치: src/modem.c:968-1001
해결: printf() + fflush() 추가 (MB_LOG_INFO는 syslog만 출력)
결과:
```
[INFO] Connection speed: 1200 baud
[INFO] Adjusting serial port speed to match connection: 1200 baud
[INFO] Serial port speed adjusted successfully to 1200 baud
```

[18-2] ✅ Draining Loop 진단 코드 추가 (완료)
문제: "Hardware message processed during drain phase" 이후 프로그램 멈춤
위치: src/bridge.c:800-845
추가 내용:
- 각 iteration 시작/종료 로그
- serial_read() 호출 전후 로그
- modem state 확인 로그
- drain_attempts 증가 추적
발견: Iteration 6에서 serial_read() 호출 후 blocking됨

[18-3] ✅ serial_read() 블로킹 문제 수정 (완료)
문제:
- Serial port가 blocking mode (VMIN=1, VTIME=0)
- serial_read()가 read() 직접 호출
- Draining loop에서 데이터 없으면 영원히 대기

해결책 (modem_sample 패턴):
위치: src/serial.c:298-381
구현:
```c
// select() with 100ms timeout
FD_ZERO(&readfds);
FD_ZERO(&exceptfds);
FD_SET(port->fd, &readfds);
FD_SET(port->fd, &exceptfds);

tv.tv_sec = 0;
tv.tv_usec = 100000;  /* 100ms */

sel = select(port->fd + 1, &readfds, NULL, &exceptfds, &tv);

if (sel == 0) {
    return 0;  // Timeout - no data available
}

// Only read when data is ready
if (FD_ISSET(port->fd, &readfds)) {
    n = read(port->fd, buffer, size);
}
```

결과:
- Draining loop가 timeout으로 정상 종료 가능
- Blocking mode 유지하면서 non-blocking 동작
- modem_sample 패턴 완전 호환

빌드: ✅ 성공 (2025-10-16)

[18-4] ⏳ 통합 테스트 (대기 중)
예상 동작:

1. Draining loop 완료:
```
[DEBUG] Draining iteration 6: calling serial_read()...
[DEBUG] serial_read() returned: 0 bytes
[INFO] ===== DRAINING LOOP EXITED =====
[INFO] Buffer drain complete (6 attempts)
```

2. Thread 생성:
```
[INFO] === MODEM CONFIGURATION SUMMARY ===
[INFO] Creating Serial/Modem thread (Level 1)...
[INFO] [Thread 1] Serial/Modem thread started
```

3. Health Check (src/bridge.c:736-751):
```
[INFO] [Thread 1] Modem is ALREADY ONLINE (CONNECT received during init)
[INFO] [Thread 1] Enabling timestamp transmission immediately
```

4. Timestamp 전송 (src/bridge.c:1591-1628):

첫 번째 (즉시 전송):
```
[INFO] [Thread 1] Modem ONLINE detected, first timestamp will send immediately
[INFO] [Thread 1] Sending timestamp: \r\n[2025-10-16 12:34:56] Level 1 Active\r\n
[INFO] [Thread 1] Timestamp sent successfully: 45 bytes
```

이후 (10초마다):
```
[DEBUG] [Thread 1] Next timestamp countdown: 10 seconds remaining
...
[INFO] [Thread 1] Sending timestamp: \r\n[2025-10-16 12:35:06] Level 1 Active\r\n
[INFO] [Thread 1] Timestamp sent successfully: 45 bytes
```

현재 상태:
---------
✅ Baudrate 조정: 완료 및 테스트 성공
✅ Draining loop 진단: 완료
✅ serial_read() 수정: 완료 (select() with timeout)
✅ 빌드: 성공
⏳ 실제 하드웨어 테스트: 대기 중

다음 단계:
---------
1. 실제 하드웨어로 테스트 실행:
   ```bash
   ./build/modembridge -c modembridge.conf 2>&1 | tee test.log
   ```

2. 로그 확인:
   - [ ] Draining loop 정상 종료
   - [ ] Thread 생성 성공
   - [ ] Health check ONLINE 감지
   - [ ] Timestamp 전송 (즉시 첫 전송, 이후 10초마다)

3. 문제 발생 시 로그 분석 및 추가 수정

주요 수정 파일:
-------------
- src/serial.c:345-407 - serial_read() with epoll (from select())
- src/bridge.c:800-845 - Draining loop (진단 코드 포함)
- src/bridge.c:1526-1574 - Health check ONLINE detection
- src/bridge.c:1591-1628 - Timestamp transmission loop (즉시 첫 전송)
- src/modem.c:968-1001 - Baudrate adjustment (stdout 출력 추가)
- include/serial.h:17 - serial_port_t에 epoll_fd 추가

참고 문서:
---------
- DRAINING_LOOP_DIAGNOSTIC.md
- TIMESTAMP_TRANSMISSION_FIX.md
- BAUDRATE_ADJUSTMENT_ANALYSIS.md
- SERIAL_READ_BLOCKING_FIX.md


================================================================================
Phase 19: Level 2 개발 (Telnet 서버 연결) - ✅ 완료
================================================================================

목표:
-----
Level 2 구현: Telnet 서버와의 브리지 연결
- DCD rising edge 감지 시 telnet 연결
- Telnet ↔ Serial 양방향 데이터 전송
- IAC 프로토콜 협상 및 처리

작업 완료:
---------
✅ Telnet 연결 관리 (non-blocking)
✅ IAC 프로토콜 처리
✅ 양방향 데이터 버퍼링 (thread-safe)
✅ 상태: 완료 및 테스트 성공 (2025-10-17)


================================================================================
Phase 20: Level 3 개발 (Dual Pipeline Management) - ✅ 완료
================================================================================

목표:
-----
Level 3 구현: Level 1과 Level 2 사이의 양방향 파이프라인 관리
- 공정 스케줄링 (Fair scheduling)
- 백프레셔 관리 (Backpressure)
- 프로토콜 필터링 (Hayes/ANSI/Telnet IAC)
- 상태 머신 기반 lifecycle 관리

주요 기능:
---------
✅ 상태 머신: UNINITIALIZED → READY → CONNECTING → DATA_TRANSFER → FLUSHING → SHUTDOWN
✅ DCD 이벤트 기반 파이프라인 활성화
✅ 양방향 파이프라인:
   - Serial → Telnet: Hayes 필터링
   - Telnet → Serial: IAC 필터링
✅ 공정 스케줄링: 라운드로빈, 기아 방지, 지연 상한 보장
✅ 백프레셔: 수위선 기반 흐름 제어
✅ Thread-safe 버퍼: ts_serial_to_telnet_buf, ts_telnet_to_serial_buf

작업 내역:
---------
[20-1] ✅ Level 3 기본 구조 구현 (완료)
- 상태 머신 설계 및 구현
- 이중 버퍼 시스템
- 파이프라인 초기화

[20-2] ✅ DCD 이벤트 통합 (완료)
- modem.c → bridge.c → level3.c 이벤트 전달
- DCD rising: READY → CONNECTING 전환
- DCD falling: 즉시 정리 및 종료

[20-3] ✅ Telnet 연결 관리 (완료)
- Level 3 state machine에서 연결 제어
- Non-blocking 연결 완료 감지
- Level 2 ready 플래그 관리

[20-4] ✅ 양방향 데이터 흐름 수정 (완료)
- Modem thread: Serial → buffer (Level 3 모드 감지)
- Telnet thread: buffer 읽기 건너뛰기 (Level 3 모드 감지)
- Level 3 pipeline: buffer → 필터링 → 대상

[20-5] ✅ CONNECT 메시지 처리 버그 수정 (완료)
- hardware_msg_handled 조건으로 1회만 실행
- 일반 데이터는 Level 3 파이프라인으로 전달

[20-6] ✅ 통합 테스트 (완료)
- Client → Telnet Server: ✅ 정상
- Telnet Server → Client: ✅ 정상
- Echo 테스트: ✅ 성공
- Timestamp 수신: ✅ 정상

결과:
-----
✅ Level 3 dual pipeline 완전 구현
✅ 양방향 데이터 전송 정상 작동
✅ 상태 머신 lifecycle 관리 완료
✅ 모든 레벨 (Level 1/2/3) 빌드 호환성 보장

상태: ✅ 완료 및 테스트 성공 (2025-10-17)

주요 수정 파일:
-------------
- src/bridge.c: Thread 간 Level 3 모드 감지 로직
- src/level3.c: Pipeline 버퍼 읽기/쓰기, 상태 머신
- src/modem.c: DCD 이벤트 콜백
- include/level3.h: Level 3 구조 정의


================================================================================
향후 계획 (선택사항)
================================================================================

Phase 21: Level 3 추가 테스트 (선택사항)
- 장시간 안정성 테스트
- 에러 케이스 테스트
- 성능 최적화

Phase 20: 성능 최적화 (선택사항)
- 처리량 개선
- 메모리 사용량 최적화
- CPU 사용률 최적화

Phase 21: 보안 강화 (선택사항)
- 입력 검증 강화
- 버퍼 오버플로우 방지
- 보안 감사


================================================================================
빌드 및 실행
================================================================================

빌드:
```bash
make clean && make
```

실행:
```bash
# Foreground
./build/modembridge -c modembridge.conf

# Daemon mode with verbose logging
./build/modembridge -c modembridge.conf -d -v
```

로그 확인:
```bash
# stdout/stderr
./build/modembridge -c modembridge.conf 2>&1 | tee modembridge.log

# syslog
journalctl -u modembridge -f
# or
tail -f /var/log/syslog | grep modembridge
```


[18-5] ✅ Serial port epoll 적용 (완료)
목표: select()를 epoll로 전환하여 write 작업 준비
위치:
- include/serial.h:17 - serial_port_t에 epoll_fd 추가
- src/serial.c:7 - sys/epoll.h include
- src/serial.c:21 - serial_init()에서 epoll_fd = -1 초기화
- src/serial.c:95-118 - serial_open()에서 epoll_create1() + EPOLL_CTL_ADD
- src/serial.c:159-164 - serial_close()에서 close(epoll_fd)
- src/serial.c:345-407 - serial_read()를 epoll_wait()로 전환

구현 내용:
```c
// serial_open()에서
port->epoll_fd = epoll_create1(EPOLL_CLOEXEC);
struct epoll_event ev;
ev.events = EPOLLIN | EPOLLERR | EPOLLHUP;
ev.data.fd = port->fd;
epoll_ctl(port->epoll_fd, EPOLL_CTL_ADD, port->fd, &ev);

// serial_read()에서
struct epoll_event events[1];
nfds = epoll_wait(port->epoll_fd, events, 1, 100);  // 100ms timeout

if (events[0].events & (EPOLLERR | EPOLLHUP)) {
    // Error handling
}
if (events[0].events & EPOLLIN) {
    n = read(port->fd, buffer, size);
}

// serial_close()에서
close(port->epoll_fd);
```

특징:
- 각 serial port가 독립적인 epoll 인스턴스 보유
- epoll_fd를 serial_open()에서 생성하여 재사용 (효율적)
- EPOLLIN | EPOLLERR | EPOLLHUP 이벤트 모니터링
- 100ms timeout 유지 (기존 select()와 동일)
- Blocking mode 설정 유지 (VMIN=1, VTIME=0)

장점:
✅ Serial과 Telnet이 각각 독립적인 epoll 운영
✅ Write 작업 확장 준비 완료 (EPOLLOUT 추가 가능)
✅ epoll_fd 재사용으로 오버헤드 최소화
✅ 모듈 독립성 및 책임 분리
✅ 이벤트 통합 처리 (EPOLLIN | EPOLLERR | EPOLLHUP)

빌드: ✅ 성공 (2025-10-16)
테스트: ⏳ 하드웨어 테스트 대기


[18-6] ✅ Level 1 timestamp 전송 로직 변경 (완료)
목표: CONNECT 후 첫 timestamp를 즉시 전송, 이후 10초마다 전송
변경 전: CONNECT → 20초 대기 → 첫 전송 → 10초마다 전송
변경 후: CONNECT → 즉시 첫 전송 → 10초마다 전송

위치: src/bridge.c:1591-1628

구현 내용:
```c
// 1. CONNECT 감지 시 (Line 1592-1598)
if (connect_time == 0) {
    connect_time = now;
    /* last_timestamp_sent를 0으로 유지 (즉시 전송 트리거) */
    printf("[INFO] Modem ONLINE detected, first timestamp will send immediately\n");
}

// 2. Countdown 로직 수정 (Line 1600-1615)
if (last_timestamp_sent > 0) {
    /* 후속 timestamp만 countdown 표시 (첫 timestamp는 즉시 전송) */
    time_t remaining = TIMESTAMP_INTERVAL - (now - last_timestamp_sent);
    printf("[DEBUG] Next timestamp countdown: %ld seconds remaining\n", remaining);
}

// 3. 전송 조건 변경 (Line 1622-1628)
if (last_timestamp_sent == 0) {
    /* 첫 번째 timestamp - 즉시 전송 */
    should_send_timestamp = true;
} else if (now - last_timestamp_sent >= TIMESTAMP_INTERVAL) {
    /* 후속 timestamp - 10초 후 전송 */
    should_send_timestamp = true;
}
```

주요 변경점:
- TIMESTAMP_DELAY 상수 제거
- 첫 번째 timestamp 20초 대기 로직 제거
- last_timestamp_sent == 0 조건으로 즉시 전송
- 첫 timestamp countdown 메시지 제거 (즉시 전송되므로 불필요)
- TIMESTAMP_INTERVAL (10초)은 그대로 유지

예상 동작:
```
[INFO] [Thread 1] Modem ONLINE detected, first timestamp will send immediately
[INFO] [Thread 1] Sending timestamp: \r\n[2025-10-16 12:34:56] Level 1 Active\r\n
[INFO] [Thread 1] Timestamp sent successfully: 45 bytes
[DEBUG] [Thread 1] Next timestamp countdown: 10 seconds remaining
...
[INFO] [Thread 1] Sending timestamp: \r\n[2025-10-16 12:35:06] Level 1 Active\r\n
```

빌드: ✅ 성공 (2025-10-16)
테스트: ⏳ 하드웨어 테스트 대기


다음 작업 (선택적):
- [18-7] serial_write()에 EPOLLOUT 적용 (필요 시)
- [18-8] telnet_conn_t에 epoll 적용 (향후)
