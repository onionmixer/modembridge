ModemBridge 프로젝트 개발 계획
=====================================

프로젝트 개요:
- USB Serial을 통한 Dialup Modem과 Telnet 서버를 연결하는 Bridge 서버
- 개발 언어: C
- 최소 요구사항: Ubuntu 22.04 LTS


현재 상태:
=========
✅ Phase 1-9: 완료 (기본 기능 구현 완료)
✅ Phase 10: 완료 (통합 테스트 완료)
✅ Phase 12: 완료 (Resilient Architecture + Health Check)


Phase 12: Resilient Architecture 및 Health Check 구현 (완료)
============================================================

목표:
-----
서버 시작 시 리소스가 없어도 정상 시작되며, 리소스가 나중에 준비되면
자동으로 인식하고 사용할 수 있는 탄력적인 아키텍처 구현

핵심 원칙:
---------
1. **Non-blocking Startup**: Serial port, Modem, Telnet 서버가 없어도 서버는 시작됨
2. **Dynamic Resource Discovery**: 리소스가 나중에 준비되면 자동으로 감지하고 사용
3. **Health Check**: 서버 시작 시 한 번만 진단 정보 출력 (재시도 안 함)


리소스별 전략:
-------------

1. Serial Port
   현재 문제: serial_open() 실패 → 서버 종료
   새 동작:
   - 서버 시작 시 serial_open() 실패해도 서버는 계속 실행
   - 메인 루프에서 10초마다 자동으로 재시도
   - 연결 성공하면 자동으로 Modem 초기화하고 사용 시작

2. Modem Device
   현재: Serial port 없으면 Modem도 없음
   새 동작:
   - Serial port 연결되면 자동으로 Modem 초기화
   - AT 명령어 응답 대기

3. Telnet Server
   현재 문제: telnet_connect() 실패 → NO CARRIER만 전송, 재시도 없음
   새 동작:
   - Health check는 서버 시작 시 한 번만 (진단 목적)
   - 실제 연결은 Modem이 ATA 명령 받을 때마다 시도
   - 실패하면 NO CARRIER, 다음 ATA에서 다시 시도


Serial Port 및 Modem Health Check 상태 흐름도:
---------------------------------------------

상태 정의:
  DISCONNECTED: Serial port 없음 (초기 상태)
  READY:        Serial port 연결됨, modem 초기화됨, AT 명령 대기 중
  ONLINE:       Modem-Telnet 통신 중

동작 흐름:

1. 서버가 시작된다
   → DISCONNECTED 상태

2. Serial port health check 진행 (서버 시작 시 한 번만)
   - 성공 → 3으로
   - 실패 → DISCONNECTED 상태 유지, 5로

3. Modem health check 진행 (Serial port 연결 시)
   - 성공 → READY 상태로 전환 (AT 명령 대기)
   - 실패 → READY 상태로 전환 (modem은 나중에 응답할 수 있음)

4. READY 상태에서 동작:
   - Modem으로부터 AT 명령 수신 및 처리
   - ATA 명령 수신 시 telnet 연결 시도
     → 성공하면 ONLINE 상태로 전환
     → 실패하면 NO CARRIER 전송, READY 상태 유지

5. Background 모니터링 (상태별로 다른 동작):

   [DISCONNECTED 상태]
   - 10초마다 serial port device 존재 여부 체크
   - Device 발견되면:
     → Serial port open 시도
     → 성공 시 Modem 초기화 (health check는 안 함)
     → READY 상태로 전환

   [READY 상태]
   - Serial I/O 오류 실시간 감지
   - 오류 발생 시:
     → Serial port close
     → DISCONNECTED 상태로 전환
     → 5-DISCONNECTED로 복귀 (10초 재시도 시작)

   [ONLINE 상태]
   - Serial I/O 오류 또는 Telnet 연결 종료 실시간 감지
   - 오류/종료 발생 시:
     → Telnet 연결 종료 (있으면)
     → Serial port close
     → DISCONNECTED 상태로 전환
     → 5-DISCONNECTED로 복귀 (10초 재시도 시작)

6. 상태 전환 요약:
   DISCONNECTED --[device found + serial_open() success]--> READY
   READY --[ATA + telnet_connect() success]--> ONLINE
   ONLINE --[disconnect/error]--> DISCONNECTED
   READY --[serial error]--> DISCONNECTED

핵심 차이점:
- Health check는 서버 시작 시에만 수행 (진단 목적)
- DISCONNECTED 상태: 10초마다 device 파일 존재 확인 (polling)
- READY/ONLINE 상태: I/O 오류를 실시간 감지 (event-driven)
- 통신 중(ONLINE)에도 serial port 오류 실시간 감지 가능
- 모든 오류는 DISCONNECTED 상태로 돌아가서 10초 재시도 시작


구현 계획:
---------

[12-1] Bridge Context에 Retry State 추가
      파일: include/bridge.h

      추가 필드:
      ```c
      typedef struct {
          // 기존 필드들...

          /* Resource availability flags */
          bool serial_ready;           // Serial port 사용 가능 여부
          bool modem_ready;            // Modem 초기화 완료 여부

          /* Retry state */
          time_t last_serial_retry;    // 마지막 serial 재시도 시간
          int serial_retry_interval;   // Serial 재시도 간격 (기본 10초)
          int serial_retry_count;      // Serial 재시도 횟수 (로깅용)
      } bridge_ctx_t;
      ```

[12-2] bridge_start() 수정 - Non-blocking 시작
      파일: src/bridge.c

      현재 코드 (bridge.c:352-387):
      ```c
      int bridge_start(bridge_ctx_t *ctx)
      {
          /* Open serial port */
          int ret = serial_open(&ctx->serial, ctx->config->serial_port, ctx->config);
          if (ret != SUCCESS) {
              MB_LOG_ERROR("Failed to open serial port");
              return ret;  // ← 여기서 실패하면 서버 종료!
          }
          // ...
      }
      ```

      새 코드:
      ```c
      int bridge_start(bridge_ctx_t *ctx)
      {
          if (ctx == NULL || ctx->config == NULL) {
              return ERROR_INVALID_ARG;
          }

          MB_LOG_INFO("Starting bridge");

          /* Initialize retry state */
          ctx->serial_ready = false;
          ctx->modem_ready = false;
          ctx->last_serial_retry = 0;
          ctx->serial_retry_interval = 10;  // 10초
          ctx->serial_retry_count = 0;

          /* Try to open serial port (non-blocking) */
          int ret = serial_open(&ctx->serial, ctx->config->serial_port, ctx->config);
          if (ret == SUCCESS) {
              ctx->serial_ready = true;

              /* Initialize modem */
              modem_init(&ctx->modem, &ctx->serial);
              ctx->modem_ready = true;

              MB_LOG_INFO("Serial port opened successfully: %s",
                         ctx->config->serial_port);
          } else {
              /* Serial port not available - will retry later */
              ctx->serial_ready = false;
              ctx->modem_ready = false;
              ctx->last_serial_retry = time(NULL);

              MB_LOG_WARNING("Serial port not available: %s (will retry every %d seconds)",
                            ctx->config->serial_port, ctx->serial_retry_interval);
          }

          /* Open data log if enabled (independent of serial) */
          if (ctx->config->data_log_enabled) {
              int ret_log = datalog_open(&ctx->datalog, ctx->config->data_log_file);
              if (ret_log == SUCCESS) {
                  datalog_session_start(&ctx->datalog);
                  MB_LOG_INFO("Data logging enabled: %s", ctx->config->data_log_file);
              } else {
                  MB_LOG_WARNING("Failed to open data log, continuing without logging");
              }
          }

          ctx->state = STATE_IDLE;
          ctx->running = true;

          if (ctx->serial_ready) {
              MB_LOG_INFO("Bridge started, waiting for modem connection");
          } else {
              MB_LOG_INFO("Bridge started (waiting for serial port)");
          }

          return SUCCESS;  // 항상 성공 반환!
      }
      ```

[12-3] bridge_run() 수정 - Serial Port 자동 재시도
      파일: src/bridge.c

      현재 코드 (bridge.c:371-439):
      ```c
      int bridge_run(bridge_ctx_t *ctx)
      {
          // select() 호출
          // Serial fd와 Telnet fd 모니터링
          // ...
      }
      ```

      새 코드 (bridge_run() 시작 부분에 추가):
      ```c
      int bridge_run(bridge_ctx_t *ctx)
      {
          fd_set readfds;
          struct timeval timeout;
          int maxfd = 0;
          int ret;

          if (ctx == NULL) {
              return ERROR_INVALID_ARG;
          }

          if (!ctx->running) {
              return ERROR_GENERAL;
          }

          /* === 새로 추가: Serial Port 자동 재시도 === */
          if (!ctx->serial_ready) {
              time_t now = time(NULL);

              /* 10초마다 재시도 */
              if (now - ctx->last_serial_retry >= ctx->serial_retry_interval) {
                  ctx->last_serial_retry = now;
                  ctx->serial_retry_count++;

                  MB_LOG_INFO("Retrying serial port connection (attempt #%d): %s",
                             ctx->serial_retry_count, ctx->config->serial_port);

                  int ret = serial_open(&ctx->serial, ctx->config->serial_port,
                                       ctx->config);
                  if (ret == SUCCESS) {
                      ctx->serial_ready = true;

                      /* Initialize modem */
                      modem_init(&ctx->modem, &ctx->serial);
                      ctx->modem_ready = true;

                      MB_LOG_INFO("Serial port connected successfully after %d attempts!",
                                 ctx->serial_retry_count);

                      /* Reset retry counter for next time */
                      ctx->serial_retry_count = 0;
                  } else {
                      MB_LOG_DEBUG("Serial port still not available (retry #%d)",
                                  ctx->serial_retry_count);
                  }
              }

              /* Serial port가 없으면 짧은 sleep 후 리턴 */
              if (!ctx->serial_ready) {
                  usleep(100000);  // 100ms sleep
                  return SUCCESS;
              }
          }
          /* === 자동 재시도 로직 끝 === */

          /* Setup file descriptor set */
          FD_ZERO(&readfds);

          /* Add serial port (if ready) */
          int serial_fd = -1;
          if (ctx->serial_ready) {
              serial_fd = serial_get_fd(&ctx->serial);
              if (serial_fd >= 0) {
                  FD_SET(serial_fd, &readfds);
                  maxfd = MAX(maxfd, serial_fd);
              }
          }

          /* Add telnet socket if connected */
          if (telnet_is_connected(&ctx->telnet)) {
              int telnet_fd = telnet_get_fd(&ctx->telnet);
              if (telnet_fd >= 0) {
                  FD_SET(telnet_fd, &readfds);
                  maxfd = MAX(maxfd, telnet_fd);
              }
          }

          /* Set timeout */
          timeout.tv_sec = 1;
          timeout.tv_usec = 0;

          /* Wait for activity (기존 코드 계속...) */
          // ...
      }
      ```

[12-4] bridge_process_serial_data() 수정
      Serial port가 갑자기 끊어진 경우 처리:

      ```c
      int bridge_process_serial_data(bridge_ctx_t *ctx)
      {
          // ...

          /* Read from serial port */
          n = serial_read(&ctx->serial, buf, sizeof(buf));
          if (n < 0) {
              MB_LOG_ERROR("Serial read error - serial port disconnected?");

              /* Mark serial as not ready */
              ctx->serial_ready = false;
              ctx->modem_ready = false;
              ctx->last_serial_retry = time(NULL);

              /* Close serial port */
              serial_close(&ctx->serial);

              MB_LOG_WARNING("Serial port lost, will retry connection");

              return ERROR_IO;
          }

          // ...
      }
      ```

[12-5] Telnet 연결 - 현재 동작 유지 (재시도 안 함)
      파일: src/bridge.c

      현재 bridge_handle_modem_connect() 동작:
      ```c
      int bridge_handle_modem_connect(bridge_ctx_t *ctx)
      {
          MB_LOG_INFO("Modem connection established, connecting to telnet server");

          /* Connect to telnet server */
          int ret = telnet_connect(&ctx->telnet, ctx->config->telnet_host,
                                   ctx->config->telnet_port);
          if (ret != SUCCESS) {
              MB_LOG_ERROR("Failed to connect to telnet server");
              modem_send_response(&ctx->modem, MODEM_RESP_NO_CARRIER);
              ctx->state = STATE_IDLE;
              return ret;
          }
          // ...
      }
      ```

      → 이 동작 유지!
      - ATA 명령마다 telnet_connect() 시도
      - 실패하면 NO CARRIER
      - 다음 ATA에서 다시 시도

[12-6] Health Check 모듈 구현
      파일: include/healthcheck.h, src/healthcheck.c

      목적: 서버 시작 시 한 번만 진단 정보 출력

      구조체:
      ```c
      typedef enum {
          HEALTH_STATUS_OK,       // 정상
          HEALTH_STATUS_WARNING,  // 경고
          HEALTH_STATUS_ERROR,    // 오류
          HEALTH_STATUS_UNKNOWN   // 알 수 없음
      } health_status_t;

      typedef struct {
          health_status_t status;
          char message[SMALL_BUFFER_SIZE];
      } health_check_result_t;

      typedef struct {
          health_check_result_t serial_port;
          health_check_result_t modem_device;
          health_check_result_t telnet_server;
      } health_report_t;
      ```

      함수:
      ```c
      // 전체 health check 수행 (한 번만)
      int healthcheck_run(const config_t *cfg, health_report_t *report);

      // 개별 체크 (타임아웃 있음, 비차단)
      int healthcheck_serial_port(const char *device,
                                  health_check_result_t *result);
      int healthcheck_modem_device(const char *device, const config_t *cfg,
                                   health_check_result_t *result);
      int healthcheck_telnet_server(const char *host, int port,
                                    health_check_result_t *result);

      // 결과 출력
      void healthcheck_print_report(const health_report_t *report);
      ```

[12-7] healthcheck_serial_port() 구현
      ```c
      int healthcheck_serial_port(const char *device, health_check_result_t *result)
      {
          result->status = HEALTH_STATUS_UNKNOWN;

          /* 1. 파일 존재 확인 */
          if (access(device, F_OK) != 0) {
              result->status = HEALTH_STATUS_ERROR;
              snprintf(result->message, sizeof(result->message),
                      "Device does not exist: %s", device);
              return ERROR_IO;
          }

          /* 2. Character device 확인 */
          struct stat st;
          if (stat(device, &st) != 0 || !S_ISCHR(st.st_mode)) {
              result->status = HEALTH_STATUS_ERROR;
              snprintf(result->message, sizeof(result->message),
                      "Not a character device: %s", device);
              return ERROR_IO;
          }

          /* 3. 접근 권한 확인 */
          if (access(device, R_OK | W_OK) != 0) {
              result->status = HEALTH_STATUS_WARNING;
              snprintf(result->message, sizeof(result->message),
                      "Permission denied: %s (try: sudo usermod -a -G dialout $USER)",
                      device);
              return ERROR_IO;
          }

          /* 4. 실제 오픈 시도 (즉시 닫음) */
          int fd = open(device, O_RDWR | O_NOCTTY | O_NONBLOCK);
          if (fd < 0) {
              result->status = HEALTH_STATUS_WARNING;
              snprintf(result->message, sizeof(result->message),
                      "Failed to open: %s (%s)", device, strerror(errno));
              return ERROR_IO;
          }
          close(fd);

          /* 성공 */
          result->status = HEALTH_STATUS_OK;
          snprintf(result->message, sizeof(result->message),
                  "Device exists and accessible: %s", device);
          return SUCCESS;
      }
      ```

[12-8] healthcheck_modem_device() 구현 (선택적)
      2초 타임아웃으로 AT 명령 테스트:

      ```c
      int healthcheck_modem_device(const char *device, const config_t *cfg,
                                   health_check_result_t *result)
      {
          serial_port_t port;
          char response[SMALL_BUFFER_SIZE];
          const char *at_cmd = "AT\r\n";
          struct timeval tv;
          fd_set readfds;
          int ret;

          result->status = HEALTH_STATUS_UNKNOWN;

          /* Temporary port open */
          serial_init(&port);
          if (serial_open(&port, device, cfg) != SUCCESS) {
              result->status = HEALTH_STATUS_ERROR;
              snprintf(result->message, sizeof(result->message),
                      "Cannot open serial port");
              return ERROR_IO;
          }

          /* Send AT command */
          serial_write(&port, at_cmd, strlen(at_cmd));

          /* Wait for response (2 second timeout) */
          FD_ZERO(&readfds);
          FD_SET(port.fd, &readfds);
          tv.tv_sec = 2;
          tv.tv_usec = 0;

          ret = select(port.fd + 1, &readfds, NULL, NULL, &tv);

          if (ret > 0) {
              ssize_t n = serial_read(&port, response, sizeof(response) - 1);
              if (n > 0) {
                  result->status = HEALTH_STATUS_OK;
                  snprintf(result->message, sizeof(result->message),
                          "Modem responded to AT command");
              } else {
                  result->status = HEALTH_STATUS_WARNING;
                  snprintf(result->message, sizeof(result->message),
                          "Read error from modem");
              }
          } else if (ret == 0) {
              result->status = HEALTH_STATUS_WARNING;
              snprintf(result->message, sizeof(result->message),
                      "No response (timeout 2s) - modem may be offline");
          } else {
              result->status = HEALTH_STATUS_ERROR;
              snprintf(result->message, sizeof(result->message),
                      "Select error: %s", strerror(errno));
          }

          serial_close(&port);
          return SUCCESS;
      }
      ```

[12-9] healthcheck_telnet_server() 구현
      5초 타임아웃으로 TCP 연결 테스트:

      ```c
      int healthcheck_telnet_server(const char *host, int port,
                                    health_check_result_t *result)
      {
          int sockfd;
          struct sockaddr_in server_addr;
          struct hostent *he;
          struct timeval tv;
          fd_set writefds;
          int ret;

          result->status = HEALTH_STATUS_UNKNOWN;

          /* DNS resolution */
          he = gethostbyname(host);
          if (he == NULL) {
              result->status = HEALTH_STATUS_ERROR;
              snprintf(result->message, sizeof(result->message),
                      "Failed to resolve: %s", host);
              return ERROR_CONNECTION;
          }

          /* Create socket */
          sockfd = socket(AF_INET, SOCK_STREAM, 0);
          if (sockfd < 0) {
              result->status = HEALTH_STATUS_ERROR;
              snprintf(result->message, sizeof(result->message),
                      "Failed to create socket");
              return ERROR_CONNECTION;
          }

          /* Non-blocking */
          fcntl(sockfd, F_SETFL, O_NONBLOCK);

          /* Connect */
          memset(&server_addr, 0, sizeof(server_addr));
          server_addr.sin_family = AF_INET;
          server_addr.sin_port = htons(port);
          memcpy(&server_addr.sin_addr, he->h_addr_list[0], he->h_length);

          ret = connect(sockfd, (struct sockaddr *)&server_addr,
                       sizeof(server_addr));

          if (ret == 0) {
              /* Immediate connection (localhost) */
              result->status = HEALTH_STATUS_OK;
              snprintf(result->message, sizeof(result->message),
                      "Connected: %s:%d", host, port);
              close(sockfd);
              return SUCCESS;
          }

          if (errno != EINPROGRESS) {
              result->status = HEALTH_STATUS_ERROR;
              snprintf(result->message, sizeof(result->message),
                      "Connection failed: %s", strerror(errno));
              close(sockfd);
              return ERROR_CONNECTION;
          }

          /* Wait for connection (5 second timeout) */
          FD_ZERO(&writefds);
          FD_SET(sockfd, &writefds);
          tv.tv_sec = 5;
          tv.tv_usec = 0;

          ret = select(sockfd + 1, NULL, &writefds, NULL, &tv);

          if (ret > 0) {
              int error = 0;
              socklen_t len = sizeof(error);
              getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &error, &len);

              if (error == 0) {
                  result->status = HEALTH_STATUS_OK;
                  snprintf(result->message, sizeof(result->message),
                          "Connected: %s:%d", host, port);
              } else {
                  result->status = HEALTH_STATUS_ERROR;
                  snprintf(result->message, sizeof(result->message),
                          "Connection failed: %s", strerror(error));
              }
          } else if (ret == 0) {
              result->status = HEALTH_STATUS_WARNING;
              snprintf(result->message, sizeof(result->message),
                      "Timeout (5s): %s:%d", host, port);
          } else {
              result->status = HEALTH_STATUS_ERROR;
              snprintf(result->message, sizeof(result->message),
                      "Select error: %s", strerror(errno));
          }

          close(sockfd);
          return SUCCESS;
      }
      ```

[12-10] healthcheck_print_report() 구현
       ```c
       void healthcheck_print_report(const health_report_t *report)
       {
           if (report == NULL) {
               return;
           }

           printf("Serial Port:\n");
           printf("  Status: %s\n",
                  report->serial_port.status == HEALTH_STATUS_OK ? "OK" :
                  report->serial_port.status == HEALTH_STATUS_WARNING ? "WARNING" :
                  report->serial_port.status == HEALTH_STATUS_ERROR ? "ERROR" : "UNKNOWN");
           printf("  %s\n", report->serial_port.message);
           printf("\n");

           printf("Modem Device:\n");
           printf("  Status: %s\n",
                  report->modem_device.status == HEALTH_STATUS_OK ? "OK" :
                  report->modem_device.status == HEALTH_STATUS_WARNING ? "WARNING" :
                  report->modem_device.status == HEALTH_STATUS_ERROR ? "ERROR" : "UNKNOWN");
           printf("  %s\n", report->modem_device.message);
           printf("\n");

           printf("Telnet Server:\n");
           printf("  Status: %s\n",
                  report->telnet_server.status == HEALTH_STATUS_OK ? "OK" :
                  report->telnet_server.status == HEALTH_STATUS_WARNING ? "WARNING" :
                  report->telnet_server.status == HEALTH_STATUS_ERROR ? "ERROR" : "UNKNOWN");
           printf("  %s\n", report->telnet_server.message);
       }
       ```

[12-11] main.c 통합
       위치: config_print() 직후, bridge_start() 호출 전

       ```c
       /* Main function */
       int main(int argc, char *argv[])
       {
           // ... (설정 로드)

           config_print(&config);

           /* === Health Check (한 번만 실행) === */
           printf("\n");
           printf("=== Health Check ===\n");

           health_report_t health;
           if (healthcheck_run(&config, &health) == SUCCESS) {
               healthcheck_print_report(&health);
           } else {
               printf("Health check failed to run\n");
           }

           printf("====================\n");
           printf("\n");

           /* Health check 결과와 관계없이 서버 시작 */
           MB_LOG_INFO("Starting server (health check completed)...");
           /* === Health Check 끝 === */

           // Setup signal handlers...

           // Daemonize...

           /* Initialize and run bridge */
           bridge_ctx_t bridge;
           bridge_init(&bridge, &config);

           /* bridge_start()는 이제 항상 성공! */
           if (bridge_start(&bridge) != SUCCESS) {
               /* 이 경우는 심각한 에러만 (메모리 부족 등) */
               MB_LOG_ERROR("Failed to start bridge (critical error)");
               ret = ERROR_GENERAL;
               goto cleanup_bridge;
           }

           /* Main loop */
           while (g_running) {
               /* bridge_run()이 serial port 재시도 처리 */
               if (bridge_run(&bridge) != SUCCESS) {
                   MB_LOG_ERROR("Bridge error, exiting...");
                   break;
               }

               if (g_reload_config) {
                   // ...
               }
           }

           // Cleanup...
       }
       ```

[12-12] Makefile 업데이트
       ```makefile
       SOURCES = src/main.c \
                 src/bridge.c \
                 src/serial.c \
                 src/modem.c \
                 src/telnet.c \
                 src/config.c \
                 src/common.c \
                 src/datalog.c \
                 src/healthcheck.c    # ← 추가

       HEADERS = include/common.h \
                 include/config.h \
                 include/serial.h \
                 include/modem.h \
                 include/telnet.h \
                 include/bridge.h \
                 include/datalog.h \
                 include/healthcheck.h  # ← 추가
       ```

[12-13] 테스트 시나리오
       1. Serial port 없이 시작
          - 서버는 정상 시작
          - 10초마다 재시도 로그 출력
          - Serial port 연결 시 자동으로 사용 시작

       2. Serial port 연결 후 제거
          - 연결 끊김 감지
          - 10초마다 재시도 시작
          - 재연결 시 자동 복구

       3. Telnet 서버 다운 상태에서 시작
          - Health check: WARNING
          - 서버는 정상 시작
          - ATA 명령 시 telnet 연결 시도
          - 실패하면 NO CARRIER
          - Telnet 서버 시작 후 다음 ATA에서 성공

       4. 모든 리소스 준비 안 된 상태
          - Health check: 모두 WARNING/ERROR
          - 서버는 정상 시작
          - Serial port 연결되면 동작 시작
          - ATA 시 Telnet 연결 시도


구현 완료 내역:
-------------
✅ [12-1] Bridge context 수정 - include/bridge.h에 retry state 추가
✅ [12-2] bridge_start() Non-blocking 수정 - 항상 SUCCESS 반환
✅ [12-3] bridge_run() Serial 재시도 로직 - 10초 간격 자동 재시도
✅ [12-4] bridge_process_serial_data() 에러 처리 - DISCONNECTED 상태 전환
✅ [12-5] Telnet 연결 동작 유지 - ATA 명령마다 재시도
✅ [12-6~10] Health check 모듈 완전 구현 - healthcheck.h, healthcheck.c
✅ [12-11] main.c 통합 - config_print() 직후 health check 실행
✅ [12-12] Makefile 업데이트 - healthcheck.c 추가, obj 디렉터리 구조 변경
✅ [12-13] 기본 테스트 완료 - DISCONNECTED 상태 동작 확인

추가 완료:
✅ Makefile obj 디렉터리 위치 변경 (build/obj → obj)


동작 흐름:
---------

서버 시작:
```
1. config_load() → 설정 파일 읽기
2. config_print() → 설정 출력
3. healthcheck_run() → 진단 (한 번만)
   ├─ Serial port 체크
   ├─ Modem 응답 체크 (선택)
   └─ Telnet 서버 체크 (한 번만!)
4. bridge_start() → 항상 성공!
   ├─ Serial port 시도
   │  ├─ 성공 → modem_init()
   │  └─ 실패 → serial_ready = false
   └─ running = true
5. 메인 루프 시작
```

메인 루프 (상태별 동작):
```
while (g_running) {
    bridge_run() {
        /* === DISCONNECTED 상태 처리 === */
        if (!serial_ready) {
            time_t now = time(NULL);

            /* 10초마다 device 파일 존재 확인 */
            if (now - last_serial_retry >= 10) {
                last_serial_retry = now;

                /* Device 파일 존재 확인 (access 사용) */
                if (access(serial_port, F_OK) == 0) {
                    /* Serial port open 시도 */
                    if (serial_open() == SUCCESS) {
                        serial_ready = true;

                        /* Modem 초기화 (health check 안 함) */
                        modem_init();
                        modem_ready = true;

                        /* → READY 상태로 전환 */
                        MB_LOG_INFO("Transitioned to READY state");
                    }
                }
            }

            /* 아직 DISCONNECTED면 대기 후 리턴 */
            if (!serial_ready) {
                usleep(100000);  // 100ms
                return SUCCESS;
            }
        }

        /* === READY/ONLINE 상태 처리 === */
        // Serial port 있으면 정상 동작
        select() {
            serial_fd 대기
            telnet_fd 대기 (ONLINE 상태일 때만)
        }

        if (serial 데이터) {
            ret = bridge_process_serial_data() {
                n = serial_read();

                /* I/O 오류 실시간 감지 */
                if (n < 0) {
                    MB_LOG_ERROR("Serial I/O error detected");

                    /* Telnet 종료 (ONLINE 상태였으면) */
                    if (telnet_is_connected()) {
                        telnet_close();
                    }

                    /* Serial 종료 */
                    serial_close();

                    /* → DISCONNECTED 상태로 전환 */
                    serial_ready = false;
                    modem_ready = false;
                    last_serial_retry = time(NULL);

                    MB_LOG_WARNING("Transitioned to DISCONNECTED state");
                    return ERROR_IO;
                }

                /* 정상 데이터 처리 */
                modem_process_input()

                if (ATA 명령) {
                    /* telnet 연결 시도 */
                    if (telnet_connect() == SUCCESS) {
                        /* → ONLINE 상태로 전환 */
                        MB_LOG_INFO("Transitioned to ONLINE state");
                    } else {
                        /* READY 상태 유지 */
                        modem_send_response(NO_CARRIER);
                    }
                }
            }
        }

        if (telnet 데이터) {
            ret = bridge_process_telnet_data() {
                n = telnet_recv();

                /* Telnet 연결 종료 감지 */
                if (n <= 0) {
                    MB_LOG_INFO("Telnet connection closed");

                    /* Telnet 종료 */
                    telnet_close();

                    /* Serial은 유지 */
                    modem_send_response(NO_CARRIER);

                    /* → READY 상태로 복귀 */
                    MB_LOG_INFO("Transitioned back to READY state");
                    return SUCCESS;
                }

                /* 정상 데이터 처리 */
                // ...
            }
        }
    }
}
```

상태 전환 정리:
- DISCONNECTED: serial_ready = false, modem_ready = false
- READY: serial_ready = true, modem_ready = true, telnet 연결 없음
- ONLINE: serial_ready = true, modem_ready = true, telnet 연결됨


Phase 1-11: 완료
================
[1-1] ✅ 디렉토리 구조 생성
[1-2] ✅ 빌드 시스템 구축
[1-3] ✅ 기본 헤더 파일 작성
[2-1] ✅ 설정 구조체 정의
[2-2] ✅ 설정 파일 파서 구현
[3-1] ✅ Serial Port 초기화
[3-2] ✅ Serial Port 읽기/쓰기 함수
[4-1] ✅ Hayes AT 명령어 처리
[4-2] ✅ Modem Handshake 구현
[4-3] ✅ Connection 상태 관리
[5-1] ✅ Telnet 연결 구현
[5-2] ✅ Telnet 프로토콜 처리
[5-3] ✅ Telnet 제어 코드 필터링
[6-1] ✅ ANSI 이스케이프 시퀀스 파서
[6-2] ✅ 양방향 ANSI 처리
[7-1] ✅ I/O 멀티플렉싱
[7-2] ✅ 양방향 데이터 전송
[7-3] ✅ 버퍼 관리
[7-4] ✅ Multibyte 문자 처리
[8-1] ✅ Modem 연결 종료 시나리오
[8-2] ✅ Telnet 연결 종료 시나리오
[8-3] ✅ 리소스 정리
[9-1] ✅ Daemon 기본 기능
[9-2] ✅ 초기화 및 메인 루프
[9-3] ✅ 에러 처리 및 복구
[10-1] ✅ 단위 테스트
[10-2] ✅ 통합 테스트
[10-3] ✅ 디버깅 모드
[11-1] ✅ 사용자 문서
[11-2] ✅ 개발자 문서
[11-3] ✅ 배포 준비


프로젝트 완료 현황:
==================

**완료된 Phase:**
- Phase 1-9: 핵심 기능 구현 (Serial, Modem, Telnet, Bridge, ANSI, Multibyte)
- Phase 10: 통합 테스트 및 디버깅
- Phase 12: Resilient Architecture + Health Check

**주요 기능:**
✅ Hayes AT 명령어 세트 완전 지원
✅ Telnet RFC 854 완전 준수
✅ ANSI 이스케이프 시퀀스 필터링
✅ UTF-8 멀티바이트 문자 안전 처리
✅ 데이터 로깅 시스템
✅ Health Check 진단 시스템
✅ Resilient Architecture (리소스 동적 감지 및 자동 복구)
✅ Non-blocking 시작 (리소스 없어도 서버 시작)
✅ 10초 간격 Serial port 자동 재시도
✅ I/O 오류 실시간 감지 및 자동 복구

**다음 단계 (선택 사항):**
- [ ] Phase 11: 문서화 개선 (사용자 가이드, API 문서)
- [ ] Phase 13: 추가 최적화 (성능 튜닝, 메모리 사용량 최적화)
- [ ] Phase 14: 추가 기능 (설정 hot-reload, 추가 AT 명령어)
- [ ] Phase 15: 프로덕션 배포 (systemd service, 패키징)
